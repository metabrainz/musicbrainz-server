-- Generated by CompileSchemaScripts.pl from:
-- 20241017-mbs-9253-13464.sql
-- 20250408-mbs-13322.sql
-- 20250425-mbs-13464.sql
-- 20241125-mbs-13832.sql
-- 20250320-mbs-13768.sql
-- 20250408-mbs-13964-all.sql
-- 20250425-mbs-13966.sql
\set ON_ERROR_STOP 1
BEGIN;
SET search_path = musicbrainz, public;
SET LOCAL statement_timeout = 0;
--------------------------------------------------------------------------------
SELECT '20241017-mbs-9253-13464.sql';


DROP TRIGGER IF EXISTS a_upd_release_group_primary_type ON release_group_primary_type;
DROP TRIGGER IF EXISTS a_upd_release_group_secondary_type ON release_group_secondary_type;

DROP TRIGGER IF EXISTS apply_artist_release_group_pending_updates ON release_group_primary_type;
DROP TRIGGER IF EXISTS apply_artist_release_group_pending_updates ON release_group_secondary_type;

DROP FUNCTION get_artist_release_group_rows(integer);

DROP INDEX artist_release_group_nonva_idx_sort;
DROP INDEX artist_release_group_va_idx_sort;

DROP TABLE artist_release_group_nonva;
DROP TABLE artist_release_group_va;
DROP TABLE artist_release_group;

CREATE TABLE artist_release_group (
    -- See comment for `artist_release.is_track_artist`.
    is_track_artist                     BOOLEAN NOT NULL,
    artist                              INTEGER NOT NULL, -- references artist.id, CASCADE
    unofficial                          BOOLEAN NOT NULL,
    primary_type_child_order            SMALLINT,
    primary_type                        SMALLINT,
    secondary_type_child_orders         SMALLINT[],
    secondary_types                     SMALLINT[],
    first_release_date                  INTEGER,
    name                                VARCHAR COLLATE musicbrainz NOT NULL,
    release_group                       INTEGER NOT NULL -- references release_group.id, CASCADE
) PARTITION BY LIST (is_track_artist);

CREATE TABLE artist_release_group_nonva
    PARTITION OF artist_release_group FOR VALUES IN (FALSE);

CREATE TABLE artist_release_group_va
    PARTITION OF artist_release_group FOR VALUES IN (TRUE);

CREATE OR REPLACE FUNCTION get_artist_release_group_rows(
    release_group_id INTEGER
) RETURNS SETOF artist_release_group AS $$
BEGIN
    -- PostgreSQL 12 generates a vastly more efficient plan when only
    -- one release group ID is passed. A condition like
    -- `rg.id = any(...)` can be over 200x slower, even with only one
    -- release group ID in the array.
    RETURN QUERY EXECUTE $SQL$
        SELECT DISTINCT ON (a_rg.artist, rg.id)
            a_rg.is_track_artist,
            a_rg.artist,
            -- Withdrawn releases were once official by definition
            bool_and(r.status IS NOT NULL AND r.status != 1 AND r.status != 5),
            rgpt.child_order::SMALLINT,
            rg.type::SMALLINT,
            array_agg(
                DISTINCT rgst.child_order ORDER BY rgst.child_order)
                FILTER (WHERE rgst.child_order IS NOT NULL
            )::SMALLINT[],
            array_agg(
                DISTINCT st.secondary_type ORDER BY st.secondary_type)
                FILTER (WHERE st.secondary_type IS NOT NULL
            )::SMALLINT[],
            integer_date(
                rgm.first_release_date_year,
                rgm.first_release_date_month,
                rgm.first_release_date_day
            ),
            rg.name,
            rg.id
        FROM (
            SELECT FALSE AS is_track_artist, rgacn.artist, rg.id AS release_group
            FROM release_group rg
            JOIN artist_credit_name rgacn ON rgacn.artist_credit = rg.artist_credit
            UNION ALL
            SELECT TRUE AS is_track_artist, tacn.artist, r.release_group
            FROM release r
            JOIN medium m ON m.release = r.id
            JOIN track t ON t.medium = m.id
            JOIN artist_credit_name tacn ON tacn.artist_credit = t.artist_credit
        ) a_rg
        JOIN release_group rg ON rg.id = a_rg.release_group
        LEFT JOIN release r ON r.release_group = rg.id
        JOIN release_group_meta rgm ON rgm.id = rg.id
        LEFT JOIN release_group_primary_type rgpt ON rgpt.id = rg.type
        LEFT JOIN release_group_secondary_type_join st ON st.release_group = rg.id
        LEFT JOIN release_group_secondary_type rgst ON rgst.id = st.secondary_type
    $SQL$ || (CASE WHEN release_group_id IS NULL THEN '' ELSE 'WHERE rg.id = $1' END) ||
    $SQL$
        GROUP BY a_rg.is_track_artist, a_rg.artist, rgm.id, rg.id, rgpt.child_order
        ORDER BY a_rg.artist, rg.id, a_rg.is_track_artist
    $SQL$
    USING release_group_id;
END;
$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION a_upd_release_group_primary_type_mirror()
RETURNS trigger AS $$
BEGIN
    -- DO NOT modify any replicated tables in this function; it's used
    -- by a trigger on mirrors.
    IF (NEW.child_order IS DISTINCT FROM OLD.child_order)
    THEN
        INSERT INTO artist_release_group_pending_update (
            SELECT id FROM release_group
            WHERE release_group.type = OLD.id
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION a_upd_release_group_secondary_type_mirror()
RETURNS trigger AS $$
BEGIN
    -- DO NOT modify any replicated tables in this function; it's used
    -- by a trigger on mirrors.
    IF (NEW.child_order IS DISTINCT FROM OLD.child_order)
    THEN
        INSERT INTO artist_release_group_pending_update (
            SELECT release_group
            FROM release_group_secondary_type_join
            WHERE secondary_type = OLD.id
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE 'plpgsql';

CREATE INDEX artist_release_group_nonva_idx_sort ON artist_release_group_nonva (artist, unofficial, primary_type_child_order NULLS FIRST, primary_type NULLS FIRST, secondary_type_child_orders NULLS FIRST, secondary_types NULLS FIRST, first_release_date NULLS LAST, name, release_group);
CREATE INDEX artist_release_group_va_idx_sort ON artist_release_group_va (artist, unofficial, primary_type_child_order NULLS FIRST, primary_type NULLS FIRST, secondary_type_child_orders NULLS FIRST, secondary_types NULLS FIRST, first_release_date NULLS LAST, name, release_group);

CREATE UNIQUE INDEX artist_release_group_nonva_idx_uniq ON artist_release_group_nonva (release_group, artist);
CREATE UNIQUE INDEX artist_release_group_va_idx_uniq ON artist_release_group_va (release_group, artist);

--------------------------------------------------------------------------------
SELECT '20250408-mbs-13322.sql';


CREATE OR REPLACE FUNCTION delete_unused_url(ids INTEGER[])
RETURNS VOID AS $$
BEGIN
  DELETE FROM url_gid_redirect WHERE new_id = any(ids);
  DELETE FROM url WHERE id = any(ids);
EXCEPTION
  WHEN foreign_key_violation THEN RETURN;
END;
$$ LANGUAGE 'plpgsql';

--------------------------------------------------------------------------------
SELECT '20250425-mbs-13464.sql';


DROP FUNCTION get_artist_release_rows(integer);

DROP TABLE artist_release_nonva;
DROP TABLE artist_release_va;
DROP TABLE artist_release;

CREATE TABLE artist_release (
    is_track_artist                     BOOLEAN NOT NULL,
    artist                              INTEGER NOT NULL,
    first_release_date                  INTEGER,
    catalog_numbers                     TEXT[],
    country_code                        CHAR(2),
    barcode                             BIGINT,
    name                                VARCHAR COLLATE musicbrainz NOT NULL,
    release                             INTEGER NOT NULL
) PARTITION BY LIST (is_track_artist);

CREATE TABLE artist_release_nonva
    PARTITION OF artist_release FOR VALUES IN (FALSE);

CREATE TABLE artist_release_va
    PARTITION OF artist_release FOR VALUES IN (TRUE);

CREATE OR REPLACE FUNCTION get_artist_release_rows(
    release_id INTEGER
) RETURNS SETOF artist_release AS $$
BEGIN
    -- PostgreSQL 12 generates a vastly more efficient plan when only
    -- one release ID is passed. A condition like `r.id = any(...)`
    -- can be over 200x slower, even with only one release ID in the
    -- array.
    RETURN QUERY EXECUTE $SQL$
        SELECT DISTINCT ON (ar.artist, r.id)
            ar.is_track_artist,
            ar.artist,
            integer_date(rfrd.year, rfrd.month, rfrd.day) AS first_release_date,
            array_agg(
                DISTINCT rl.catalog_number ORDER BY rl.catalog_number
            ) FILTER (WHERE rl.catalog_number IS NOT NULL)::TEXT[] AS catalog_numbers,
            min(iso.code ORDER BY iso.code)::CHAR(2) AS country_code,
            left(regexp_replace(
                (CASE r.barcode WHEN '' THEN '0' ELSE r.barcode END),
                '[^0-9]+', '', 'g'
            ), 18)::BIGINT AS barcode,
            r.name,
            r.id
        FROM (
            SELECT FALSE AS is_track_artist, racn.artist, r.id AS release
            FROM release r
            JOIN artist_credit_name racn ON racn.artist_credit = r.artist_credit
            UNION ALL
            SELECT TRUE AS is_track_artist, tacn.artist, m.release
            FROM medium m
            JOIN track t ON t.medium = m.id
            JOIN artist_credit_name tacn ON tacn.artist_credit = t.artist_credit
        ) ar
        JOIN release r ON r.id = ar.release
        LEFT JOIN release_first_release_date rfrd ON rfrd.release = r.id
        LEFT JOIN release_label rl ON rl.release = r.id
        LEFT JOIN release_country rc ON rc.release = r.id
        LEFT JOIN iso_3166_1 iso ON iso.area = rc.country
    $SQL$ || (CASE WHEN release_id IS NULL THEN '' ELSE 'WHERE r.id = $1' END) ||
    $SQL$
        GROUP BY ar.is_track_artist, ar.artist, rfrd.release, r.id
        ORDER BY ar.artist, r.id, ar.is_track_artist
    $SQL$
    USING release_id;
END;
$$ LANGUAGE plpgsql;

CREATE INDEX artist_release_nonva_idx_sort ON artist_release_nonva (artist, first_release_date NULLS LAST, catalog_numbers NULLS LAST, country_code NULLS LAST, barcode NULLS LAST, name, release);
CREATE INDEX artist_release_va_idx_sort ON artist_release_va (artist, first_release_date NULLS LAST, catalog_numbers NULLS LAST, country_code NULLS LAST, barcode NULLS LAST, name, release);

CREATE UNIQUE INDEX artist_release_nonva_idx_uniq ON artist_release_nonva (release, artist);
CREATE UNIQUE INDEX artist_release_va_idx_uniq ON artist_release_va (release, artist);

--------------------------------------------------------------------------------
SELECT '20241125-mbs-13832.sql';


-- MBS-14014
DROP VIEW IF EXISTS cover_art_archive.index_listing;

-- CAA view
CREATE VIEW cover_art_archive.index_listing AS
SELECT cover_art.*,
  (edit.close_time IS NOT NULL) AS approved,
  coalesce(cover_art.id = (SELECT id FROM cover_art_archive.cover_art_type
                   JOIN cover_art_archive.cover_art ca_front USING (id)
                   WHERE ca_front.release = cover_art.release
                   AND type_id = 1
                   ORDER BY ca_front.ordering
                   LIMIT 1), FALSE) AS is_front,
  coalesce(cover_art.id = (SELECT id FROM cover_art_archive.cover_art_type
                   JOIN cover_art_archive.cover_art ca_front USING (id)
                   WHERE ca_front.release = cover_art.release
                   AND type_id = 2
                   ORDER BY ca_front.ordering
                   LIMIT 1), FALSE) AS is_back,
  array(SELECT art_type.name
        FROM cover_art_archive.cover_art_type
        JOIN cover_art_archive.art_type ON cover_art_type.type_id = art_type.id
        WHERE cover_art_type.id = cover_art.id) AS types
FROM cover_art_archive.cover_art
LEFT JOIN musicbrainz.edit ON edit.id = cover_art.edit;

-- EAA view
CREATE OR REPLACE VIEW event_art_archive.index_listing AS
SELECT event_art.*,
  (edit.close_time IS NOT NULL) AS approved,
  coalesce(event_art.id = (SELECT id FROM event_art_archive.event_art_type
                   JOIN event_art_archive.event_art ea_front USING (id)
                   WHERE ea_front.event = event_art.event
                   AND type_id = 1
                   ORDER BY ea_front.ordering
                   LIMIT 1), FALSE) AS is_front,
  array(SELECT art_type.name
        FROM event_art_archive.event_art_type
        JOIN event_art_archive.art_type ON event_art_type.type_id = art_type.id
        WHERE event_art_type.id = event_art.id) AS types
FROM event_art_archive.event_art
LEFT JOIN musicbrainz.edit ON edit.id = event_art.edit;

--------------------------------------------------------------------------------
SELECT '20250320-mbs-13768.sql';


-- Medium GID

-- Creating column
ALTER TABLE medium ADD COLUMN gid uuid;

-- Generating GIDs
UPDATE medium SET gid =
    generate_uuid_v3('6ba7b8119dad11d180b400c04fd430c8', 'medium' || id);

-- Adding NOT NULL constraint
ALTER TABLE medium ALTER COLUMN gid SET NOT NULL;

-- Creating index
CREATE UNIQUE INDEX medium_idx_gid ON medium (gid);

-- Medium GID redirect
CREATE TABLE medium_gid_redirect ( -- replicate (verbose)
    gid                 UUID NOT NULL, -- PK
    new_id              INTEGER NOT NULL, -- references medium.id
    created             TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE medium_gid_redirect ADD CONSTRAINT medium_gid_redirect_pkey PRIMARY KEY (gid);

CREATE INDEX medium_gid_redirect_idx_new_id ON medium_gid_redirect (new_id);

--------------------------------------------------------------------------------
SELECT '20250408-mbs-13964-all.sql';


CREATE OR REPLACE FUNCTION set_mediums_recordings_first_release_dates(medium_ids INTEGER[])
RETURNS VOID AS $$
BEGIN
  PERFORM set_recordings_first_release_dates((
    SELECT array_agg(recording)
      FROM track
     WHERE track.medium = any(medium_ids)
  ));
  RETURN;
END;
$$ LANGUAGE 'plpgsql' STRICT;

CREATE OR REPLACE FUNCTION a_upd_medium_mirror()
RETURNS trigger AS $$
BEGIN
    -- DO NOT modify any replicated tables in this function; it's used
    -- by a trigger on mirrors.
    IF NEW.release IS DISTINCT FROM OLD.release THEN
        PERFORM set_mediums_recordings_first_release_dates(ARRAY[OLD.id]);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER a_upd_medium AFTER UPDATE ON medium
    FOR EACH ROW EXECUTE PROCEDURE a_upd_medium_mirror();

TRUNCATE recording_first_release_date;

--------------------------------------------------------------------------------
SELECT '20250425-mbs-13966.sql';


CREATE OR REPLACE FUNCTION set_release_group_first_release_date(release_group_id INTEGER)
RETURNS VOID AS $$
BEGIN
    UPDATE release_group_meta SET first_release_date_year = first.year,
                                  first_release_date_month = first.month,
                                  first_release_date_day = first.day
      FROM (
        SELECT rd.year, rd.month, rd.day
        FROM release_group
        LEFT JOIN release ON release.release_group = release_group.id
        LEFT JOIN release_first_release_date rd ON (rd.release = release.id)
        WHERE release_group.id = release_group_id
        ORDER BY
          rd.year NULLS LAST,
          rd.month NULLS LAST,
          rd.day NULLS LAST
        LIMIT 1
      ) AS first
    WHERE id = release_group_id;
    INSERT INTO artist_release_group_pending_update VALUES (release_group_id);
END;
$$ LANGUAGE 'plpgsql';

CREATE TEMPORARY TABLE tmp_release_first_release_date_2025_q2 (
    release     INTEGER NOT NULL PRIMARY KEY,
    year        SMALLINT,
    month       SMALLINT,
    day         SMALLINT
) ON COMMIT DROP;

INSERT INTO tmp_release_first_release_date_2025_q2
    SELECT * FROM get_release_first_release_date_rows('TRUE');

UPDATE release_group_meta SET first_release_date_year = first.year,
                              first_release_date_month = first.month,
                              first_release_date_day = first.day
  FROM (
    SELECT DISTINCT ON (release_group.id)
        release_group.id AS release_group, rd.year, rd.month, rd.day
    FROM release_group
    LEFT JOIN release ON release.release_group = release_group.id
    LEFT JOIN tmp_release_first_release_date_2025_q2 rd ON (rd.release = release.id)
    ORDER BY
      release_group.id,
      rd.year NULLS LAST,
      rd.month NULLS LAST,
      rd.day NULLS LAST
  ) AS first
WHERE id = first.release_group
  AND (
    first_release_date_year IS DISTINCT FROM first.year
    OR first_release_date_month IS DISTINCT FROM first.month
    OR first_release_date_day IS DISTINCT FROM first.day
  );

-- Mirrors have a `a_upd_release_group_meta_mirror` trigger which inserts
-- updated `release_group_meta` IDs into `artist_release_group_pending_update`,
-- which in turn causes the associated entries in `artist_release_group`
-- to be updated. That should be a no-op here, because the schema 30 upgrade
-- already truncates `artist_release_group` (via dropping and recreating it)
-- before this runs; but clear it anyway to avoid a pointless calculation in
-- the `apply_artist_release_group_pending_updates` function.
TRUNCATE artist_release_group_pending_update;

COMMIT;
