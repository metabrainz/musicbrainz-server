<%perl>
	# -----------------------------------------------------------------------------
	#                               Musicbrainz.org
	#                        Copyright (c) 2001 Robert Kaye
	# -----------------------------------------------------------------------------
	#  This software is provided "as is", without warranty of any kind, express or
	#  implied, including  but not limited  to the warranties of  merchantability,
	#  fitness for a particular purpose and noninfringement. In no event shall the
	#  authors or  copyright  holders be  liable for any claim,  damages or  other
	#  liability, whether  in an  action of  contract, tort  or otherwise, arising
	#  from,  out of  or in  connection with  the software or  the  use  or  other
	#  dealings in the software.
	#
	#  GPL - The GNU General Public License    http://www.gnu.org/licenses/gpl.txt
	#  Permits anyone the right to use and modify the software without limitations
	#  as long as proper  credits are given  and the original  and modified source
	#  code are included. Requires  that the final product, software derivate from
	#  the original  source or any  software  utilizing a GPL  component, such  as
	#  this, is also licensed under the GPL license.
	# -----------------------------------------------------------------------------
	#
	# Summary:
	# -----------------------------------------------------------------------------
	# Review changes made to the release before entering them.
	#
	# $Id$
	#
</%perl>
<%args>

	$mb
	$releaseid => 0
	$artistid => ""
	$artistname => ""

	$tracks
	$hasmultipletrackartists

	$discid => ""
	$toc => ""

</%args>
<%perl>

	# load the original values for review
	my %orig;
	if ($releaseid)
	{
		$orig{"mb"} = $mb;
		$orig{"releaseid"} = $releaseid;
		%orig = $m->comp("/comp/release_editor/init-editall", %orig)
	}


	# returns the full name of the given track field
	# in the ARGS hash.
	sub getField {
		my ($i, $name) = @_;
		return sprintf("tr%d_%s", $i, $name);
    }

	# Maintain a list of Artists cached by ID.
	my $GetCachedArtist = do
	{
		my %cache;
		sub
		{
			my ($id) = @_;
			return $cache{$id} if (exists $cache{$id});
			my $artist = $m->comp("/comp/loadartist", $mb, $id);
			return ($cache{$id} = $artist);
		};
	};

	# prepare artist artist object
	my $artist = &$GetCachedArtist($artistid);

	# prepare release object
	my $release = MusicBrainz::Server::Release->new($mb->{DBH});
	$release->SetId(0);
	# Hack.  Maybe $release->SetAlbumMeta(...) would be a better method
	$release->{trackcount} = 0;
	$release->{discidcount} = 0;
	$release->{puidcount} = 0;

	$release = $m->comp("/comp/loadrelease", $mb, $releaseid)
		if (defined $releaseid && MusicBrainz::Server::Validation::IsNonNegInteger($releaseid) && $releaseid);

	$release->SetArtist($artist->GetId);
	$release->SetName($ARGS{"releasename"});
	$release->SetLanguageId($ARGS{"attr_language"});
	$release->SetScriptId($ARGS{"attr_script"});
	$release->SetAttributes($ARGS{"attr_type"}, $ARGS{"attr_status"});
	$release->SetModPending if ($orig{"releasename"} ne $ARGS{"releasename"});
	$release->SetMultipleTrackArtists($hasmultipletrackartists);



	# MOD_EDIT_RELEASE_EVENTS_OLD (RELEASE_EVENTS)
	# get all defined release events from the arguments hash
	# and fill the list of new release objects
	require MusicBrainz::Server::ReleaseEvent;
	my @revnew;
	my %revorighash;
	my %revremovehash;
	my (@adds, @edits, @removes);
	my $bogus_date = 0;
	for my $j (sort map { /^rev_year-(\d+)$/ ? ($1) : () } keys %ARGS)
	{
		my $rev_year = $ARGS{"rev_year-$j"};
		my $rev_month = $ARGS{"rev_month-$j"};
		my $rev_day = $ARGS{"rev_day-$j"};
		my $rev_country = $ARGS{"rev_country-$j"};
		my $rev_catno = $ARGS{"rev_catno-$j"};
		my $rev_barcode = $ARGS{"rev_barcode-$j"};
		my $rev_label = $ARGS{"rev_label-$j"};
		my $rev_labelname = $ARGS{"rev_labelname-$j"};
		my $rev_format = $ARGS{"rev_format-$j"};
		my $rev_id = $ARGS{"rev_id-$j"};
		my $rev_clear = $ARGS{"rev_clear-$j"};

		$rev_year = "" if ($rev_year eq "yyyy");
		$rev_month = "" if ($rev_month eq "mm");
		$rev_day = "" if ($rev_day eq "dd");

		if (!$rev_clear)
		{
			# Do not validate if all fields are blank, or the
			# fields are blank and the release country is set to the default one.
			MusicBrainz::Server::Validation::TrimInPlace($rev_year, $rev_month, $rev_day, $rev_country);
			if (!($rev_year eq "" and $rev_month eq "" and $rev_day eq "" and
				 ($rev_country eq "" or $rev_country eq UserPreference::get("default_country"))))
			{
				# we insist on a valid country
				MusicBrainz::Server::Validation::IsNonNegInteger($rev_country)
					or return $m->comp("/comp/error",
						"Error: invalid release country",
						0, 1,
					);

				# we insist on a valid date
				my @ymd = MusicBrainz::Server::Validation::IsValidDate($rev_year, $rev_month, $rev_day)
					or return $m->comp("/comp/error",
						"Error: invalid release date",
						0, 1,
					);

				my $rev = MusicBrainz::Server::ReleaseEvent->new($mb->{DBH});
				$rev->SetId($rev_id);
				$rev->SetCountry($rev_country);
				$rev->SetYMD(@ymd);
				$rev->SetCatNo($rev_catno);
				$rev->SetBarcode($rev_barcode);
				$rev->SetLabelName($rev_labelname);
				$rev->SetLabel($rev_label);
				$rev->SetFormat($rev_format);
				$rev->SetRelease($releaseid);
				push @revnew, $rev;
			}
		}
	}

	for my $j (sort map { /^rev_year-(\d+)$/ ? ($1) : () } keys %orig)
	{
		my $rev_year = $orig{"rev_year-$j"};
		my $rev_month = $orig{"rev_month-$j"};
		my $rev_day = $orig{"rev_day-$j"};
		my $rev_id = $orig{"rev_id-$j"};

		# flag a bad date if the validation returns false
		my @ymd = MusicBrainz::Server::Validation::IsValidDate($rev_year, $rev_month, $rev_day)
			or next;

		my $rev = MusicBrainz::Server::ReleaseEvent->new($mb->{DBH});
		$rev->SetCountry($orig{"rev_country-$j"});
		$rev->SetYMD(@ymd);
		$rev->SetCatNo($orig{"rev_catno-$j"});
		$rev->SetBarcode($orig{"rev_barcode-$j"});
		$rev->SetLabel($orig{"rev_label-$j"});
		$rev->SetLabelName($orig{"rev_labelname-$j"});
		$rev->SetFormat($orig{"rev_format-$j"});
		$rev->SetId($rev_id);
		$revorighash{$rev->GetId} = $rev;
		$revremovehash{$rev->GetId} = $rev;
	}

	for my $i (0 .. @revnew-1)
	{
		my $newrev = $revnew[$i];

		# old value is empty, and new value is not empty.
		# we've got an added release event
		if (!MusicBrainz::Server::Validation::IsNonNegInteger($newrev->GetId))
		{
			push @adds, $newrev;
			next;
		}

		# for remove/edits of individual events, we'll need
		# a confirmed release event id. load object from the
		# database.
		my $oldrev = $revorighash{$newrev->GetId}
			or next;

		my @oymd = $oldrev->GetYMD;
		my @nymd = $newrev->GetYMD;
		if ($oymd[0] != $nymd[0] or $oymd[1] != $nymd[1] or
			$oymd[2] != $nymd[2] or $oldrev->GetCountry != $newrev->GetCountry or
			$oldrev->GetCatNo ne $newrev->GetCatNo or
			$oldrev->GetBarcode ne $newrev->GetBarcode or
			$oldrev->GetLabel != $newrev->GetLabel or
			$oldrev->GetFormat != $newrev->GetFormat)
		{
			push @edits, $newrev;
		}
		delete $revremovehash{$newrev->GetId};
	}

	# add all edits which weren't handled above (e.g. which were deleted
	# from the form) to the @removes list.
	for my $revid (keys %revremovehash)
	{
		push @removes, $revremovehash{$revid};
	}

	# $m->out("Adds:". join ",", map { $_->ToString } @adds );
	# $m->out("<br/>Edits:". join ",", map { $_->ToString } @edits );
	# $m->out("<br/>Removes:". join ",", map { $_->ToString } @removes );


	# if editmode is true, we're editing a release, else
	# we're adding one.
	my $editmode = $ARGS{"v::action"} ne "/cdi/enter.html";

	# prepare 1..n track objects
	my @deletedtracks;
	my @tracks;
	for (my $i = 0; $i < $tracks; $i++)
	{
		# only use the tracks which are not choosed to be deleted.
		if (!$ARGS{"trackdel$i"})
		{
			# initialise track object
			my $trackid = $ARGS{"trackid$i"};
			my $tr = MusicBrainz::Server::Track->new($mb->{DBH});
			$tr->SetId($trackid);
			$tr->LoadFromId
				or return $m->comp("/comp/error",
					"Track '$trackid' not found in the database.",
					1, 1,
				)
				if ($trackid ne "");

			$tr->SetSequence($ARGS{"trackseq$i"});
			$tr->SetName($ARGS{"track$i"});
			$tr->SetLength(MusicBrainz::Server::Track::UnformatTrackLength($ARGS{"tracklength$i"}));

			# set track artist, if it is defined, or
			# use release artist
			if ($ARGS{"hasmultipletrackartists"})
			{
				# update track object with values from artist object.
				my $tr_artistid = $ARGS{getField($i, "artistid")};
				my $tr_artist = &$GetCachedArtist($tr_artistid);

				$tr->SetArtist($tr_artist->GetId);
				$tr->SetArtistName($tr_artist->GetName);
			}
			else
			{
				$ARGS{getField($i, "artistid")} = $artistid;
				$ARGS{getField($i, "artistname")} = $artistname;
			}
			push @tracks, $tr;
		}
	}
	$release->{trackcount} = (@tracks);

	my $ov;
	my $nv;
	my $releasechanges = 0;
	my $trackchanges = 0;

</%perl>


	<& /comp/tablebegin, title => $editmode ? "Review edits" : "Review add release edit" &>

		<& /comp/release_editor/steps, %ARGS, stepsleft => 1 &>

			<table class="review" style="margin-bottom: 15px">
				<tr>
					<td>
						Please review the release you are about to enter into
						the database before you click on <strong>Add release &raquo;</strong>.

%	if (!$editmode)
%	{


%	}
%	else
%	{

					Please review the edits that will be entered into
					the database before you click on <strong>Enter edits &raquo;</strong>.

					Some <& /comp/linkdoc, "EditType", "edit types" &> are
					applied instantly, others will need approval of other
					MusicBrainz editors. Please see <& /comp/linkdoc,
					"HowEditingWorks", "how editing works" &> for
					additional information.

					You can get additional information about the specific
					edit types if you click on their respective titles below.

%	}

					</td>
				</tr>
			</table>

%	if ($ARGS{"v::action"} ne "/cdi/enter.html")
%	{

			<table class="review">
				<tr class="header">
					<td class="type">Release:</td>
					<td class="newvalue">Change:</td>
%#					<td class="autoedit">Needs voting:</td>
				</tr>

<%perl>

		# changed release artist?
		my $orig_artistid = $orig{"artistid"};
		my $orig_artistidname = $orig{"artistname"};

		my $new_artistid = $ARGS{"artistid"};
		my $new_artistname = $ARGS{"artistname"};

		# raise flags which define if we need the
		# track-artist mods
		my $movetracks = 0;

		(MusicBrainz::Server::Validation::IsNonNegInteger($orig_artistid) or $orig_artistid eq "*")
			or die("need non-negative integer or * \$orig_artistid=$orig_artistid");
		(MusicBrainz::Server::Validation::IsNonNegInteger($new_artistid) or $new_artistid eq "*")
			or die("need non-negative integer or * \$new_artistid=$new_artistid");

		if ($orig_artistid && $orig_artistid ne $new_artistid)
		{
			# if all tracks are set to the release artist, its a
			# single artist conversion, else a move release edit.
			$movetracks = 1;
			for (my $t=0; $t < $tracks; $t++)
			{
				my $orig_trackartistid = $orig{getField($t, "artistid")};
				my $new_trackartistid = $ARGS{getField($t, "artistid")};
				$movetracks = ($movetracks && $new_trackartistid == $new_artistid);
			}

			$m->comp(".showArtistEdit",
				mb => $mb,
				edittype => "MoveReleaseEdit",
				edittitle => "Move release",
				title => "Change artist" . ($movetracks ? " (Move tracks)" : ""),

				orig_artist => &$GetCachedArtist($orig_artistid),
				new_artist => &$GetCachedArtist($new_artistid),
				new_artistname => $ARGS{"artistname"},
				new_resolution => $ARGS{"ar_resolution"},
				cnt => ++$releasechanges
			);
		}

		# changed release name?
		my $orig_releasename = $orig{"releasename"};
		my $new_releasename = $ARGS{"releasename"};
		(defined $orig_releasename and $orig_releasename ne "")
			or die("need non-empty string \$orig_releasename=$orig_releasename");
		(defined $new_releasename and $new_releasename ne "")
			or die("need non-empty string \$new_releasename=$new_releasename");
		if ($orig_releasename ne $new_releasename)
		{
			$m->comp(".showReleaseEdit",
				mb => $mb,
				edittype => "EditReleaseNameEdit",
				edittitle => "Edit release title",

				oldvalue => $orig_releasename,
				newvalue => $new_releasename,
				modtype => &ModDefs::MOD_EDIT_RELEASE_NAME,
				cnt => ++$releasechanges
			);
		}

		# changed release attributes?
		$ov = $orig{"attr_type"}.",".$orig{"attr_status"};
		$nv = $ARGS{"attr_type"}.",".$ARGS{"attr_status"};
		if ($ov ne $nv)
		{
			my @attrvalues;
			for ($ov, $nv)
			{
				my @names = map {
					MusicBrainz::Server::Release->GetAttributeName($_) || "Not_set"
				} split ',', $_;
				my $type = ($_ eq $ov ? "Old: " : "New: ");
				push @attrvalues, (@names ? join ", ", @names : "None");
			}
			$m->comp(".showReleaseEdit",
				mb => $mb,
				edittype => "EditReleaseAttributesEdit",
				edittitle => "Edit release attributes",

				oldvalue => $attrvalues[0],
				newvalue => $attrvalues[1],
				modtype => &ModDefs::MOD_EDIT_RELEASE_ATTRS,
				cnt => ++$releasechanges
			);
		}

		# changed language/script?
		$ov = $orig{"attr_language"}.",".$orig{"attr_script"};
		$nv = $ARGS{"attr_language"}.",".$ARGS{"attr_script"};
		if ($ov ne $nv)
		{
			my @langvalues;
			for ($ov, $nv)
			{
				my ($languageid, $scriptid) = split ',', $_;
				$release->SetLanguageId($languageid);
				$release->SetScriptId($scriptid);
				my $langname = (defined $release->GetLanguage ? $release->GetLanguage->GetName : "Not_set");
				my $scriptname = (defined $release->GetScript ? $release->GetScript->GetName : "Not_set");
				push @langvalues, "$langname, $scriptname";
			}
			$m->comp(".showReleaseEdit",
				mb => $mb,
				edittype => "EditReleaseLanguageEdit",
				edittitle => "Edit language/script",

				oldvalue => $langvalues[0],
				newvalue => $langvalues[1],
				modtype => &ModDefs::MOD_EDIT_RELEASE_LANGUAGE,
				cnt => ++$releasechanges
			);
		}

		# changed releasedates?
		my $countries_menu = $m->comp("/edit/albumreleases/countries-menu.inc");
		my %country_names = map { $_->[0], $_->[1] } @$countries_menu;

		for my $rev (@adds)
		{
            $bogus_date = 1 if ($rev->GetYear == 1990 && $rev->GetMonth == 10 && $rev->GetDay == 25);
			$ov = "";
			$nv = $rev->GetSortDate;
			$nv .= " - ";
			$nv .= ($country_names{$rev->GetCountry} || "?");
			$nv .= " - Label: " . $rev->GetLabelName if $rev->GetLabel;
			$nv .= " - Catalog #: " . $rev->GetCatNo if $rev->GetCatNo;
			$nv .= " - Barcode: " . $rev->GetBarcode if $rev->GetBarcode;
			$nv .= " - Format: " . $rev->GetFormatName if $rev->GetFormat;

			# release events are special, they are entered
			# as one edit, therefore show only a link on the first
			# of n release date/country tuples.
			$m->comp(".showReleaseEdit",
				mb => $mb,
				edittype => "AddReleaseEventsEdit",
				edittitle => "Add Release Events",

				oldvalue => $ov,
				newvalue => $nv,
				modtype => &ModDefs::MOD_ADD_RELEASE_EVENTS,
				cnt => ++$releasechanges
			);
		}

		if (@edits)
		{
			my $first = 1;
			for my $rev (@edits)
			{
				my $revorig = $revorighash{$rev->GetId}
					or die("Original release event not found: ".$rev->GetId);

				$ov = $revorig->GetYear;
				$ov .= "-" . $revorig->GetMonth if ($revorig->GetMonth);
				$ov .= "-" . $revorig->GetDay if ($revorig->GetDay);
				$ov .= " - ";
				$ov .= ($country_names{$revorig->GetCountry} || "?");
				$ov .= " - Label: " . $revorig->GetLabelName if $revorig->GetLabel;
				$ov .= " - Catalog #: " . $revorig->GetCatNo if $revorig->GetCatNo;
				$ov .= " - Barcode: " . $revorig->GetBarcode if $revorig->GetBarcode;
				$ov .= " - Format: " . $revorig->GetFormatName if $revorig->GetFormat;

                $bogus_date = 1 if ($rev->GetYear == 1990 && $rev->GetMonth == 10 && $rev->GetDay == 25);
				$nv = $rev->GetYear;
				$nv .= "-" . $rev->GetMonth if ($rev->GetMonth);
				$nv .= "-" . $rev->GetDay if ($rev->GetDay);
				$nv .= " - ";
				$nv .= ($country_names{$rev->GetCountry} || "?");
				$nv .= " - Label: " . $rev->GetLabelName if $rev->GetLabel;
				$nv .= " - Catalog #: " . $rev->GetCatNo if $rev->GetCatNo;
				$nv .= " - Barcode: " . $rev->GetBarcode if $rev->GetBarcode;
				$nv .= " - Format: " . $rev->GetFormatName if $rev->GetFormat;

				$m->comp(".showReleaseEdit",
					mb => $mb,
					edittype => $first ? "EditReleaseEventsEdit" : "",
					edittitle =>  $first ? "Edit Release Events" : "",

					oldvalue => $ov,
					newvalue => $nv,
					modtype => &ModDefs::MOD_EDIT_RELEASE_EVENTS,
					cnt => ++$releasechanges
				);
				$first = 0;
			}
		}

		if (@removes)
		{
			$nv = "";
			$ov = "";
			for my $rev (@removes)
			{
				my $revorig = $revorighash{$rev->GetId}
					or die("Original release event not found: ".$rev->GetId);

				$ov .= $revorig->GetYear;
				$ov .= "-" . $revorig->GetMonth if ($revorig->GetMonth);
				$ov .= "-" . $revorig->GetDay if ($revorig->GetDay);
				$ov .= " - ";
				$ov .= ($country_names{$revorig->GetCountry} || "?");
				$ov .= " - Label: " . $revorig->GetLabelName if $revorig->GetLabel;
				$ov .= " - Catalog #: " . $revorig->GetCatNo if $revorig->GetCatNo;
				$ov .= " - Barcode: " . $revorig->GetBarcode if $revorig->GetBarcode;
				$ov .= " - Format: " . $revorig->GetFormatName if $revorig->GetFormat;
				$ov .= "<br/>";
			}

			$m->comp(".showReleaseEdit",
				mb => $mb,
				edittype => "RemoveReleaseEventsEdit",
				edittitle => "Remove Release Events",

				oldvalue => $ov,
				newvalue => $nv,
				modtype => &ModDefs::MOD_REMOVE_RELEASE_EVENTS,
				cnt => ++$releasechanges
			);
		}

		if ($bogus_date)
		{
			$m->out('<tr class="nochanges"><td colspan="3">');
            $m->comp('/comp/form/feedbackbox', "warning", "", 
			         qq|Warning! "1990-10-25" is the bogus date that Amazon gives to
                        all releases for which they don't know the actual date. <b>Please
                        use this date only if you're certain this date is correct!</b>|);
			$m->out('</td></tr>');
		}

		# if no changes were made indicate this.
		if (not $releasechanges)
		{
			$m->out('<tr class="nochanges">');
			$m->out('<td colspan="3">You have not made any release changes</td>');
			$m->out('</tr>');
		}

</%perl>
				<tr class="spacer"><td colspan="3">&nbsp;</td></tr>

				<tr class="header">
					<td class="type">Track:</td>
					<td class="newvalue">Changed:</td>
%#					<td class="autoedit">Needs&nbsp;voting:</td>
				</tr>

<%perl>

		for (my $t=0; $t < $tracks; $t++)
		{
			# get original values
			my $orig_id = $orig{"trackid$t"};
			my $orig_seq = $orig{"trackseq$t"};
			my $orig_track = $orig{"track$t"};
			my $orig_length = MusicBrainz::Server::Track::UnformatTrackLength($orig{"tracklength$t"});
			my $orig_artistid = $orig{getField($t, "artistid")};

			# get new values
			my $new_id = $ARGS{"trackid$t"};
			my $new_seq = $ARGS{"trackseq$t"};
			my $new_track = $ARGS{"track$t"};
			my $new_length = MusicBrainz::Server::Track::UnformatTrackLength($ARGS{"tracklength$t"});
			my $new_delete = $ARGS{"trackdel$t"};
			my $new_artistid = $ARGS{getField($t, "artistid")};

			# check if track was removed
			if ($new_delete)
			{
				$m->comp(".showTrackEdit",
					mb => $mb,
					edittype => "RemoveTrackEdit",
					edittitle => "Remove track",

					new_seq => $new_seq,
					new_id => $new_id,
					oldvalue => $orig_track,
					newvalue => "",
					modtype => &ModDefs::MOD_REMOVE_TRACK,
					cnt => ++$trackchanges
				);
				next;
			}

			(MusicBrainz::Server::Validation::IsNonNegInteger($new_seq))
				or die("need non-negative integer \$new_seq=$new_seq");
			(defined $new_track and $new_track ne "")
				or die("need non-empty string \$new_track=$new_track");
			(MusicBrainz::Server::Validation::IsNonNegInteger($new_artistid) or $new_artistid eq "*")
				or die("need non-negative integer or * \$new_artistid=$new_artistid");

			#if ($orig_id ne $new_id)
			#{
			#	for my $i (0 .. $tracks-1)
			#	{
			#		$orig_id = $orig{"trackid$i"};
			#		$orig_seq = $orig{"trackseq$i"};
			#		if ($new_id eq $orig_id)
			#		{
			#			$m->comp(".showTrackEdit",
			#				mb => $mb,
			#				edittype => "EditTrackNumberEdit",
			#				edittitle => "Edit Track Number",
			#
			#				new_seq => $new_seq,
			#				new_id => $new_id,
			#				oldvalue => $orig_seq,
			#				newvalue => $new_seq,
			#				modtype => &ModDefs::MOD_EDIT_TRACKNUM,
			#				cnt => ++$trackchanges
			#			);
			#
			#			# update original values for diff.
			#			$orig_track = $orig{"track$i"};
			#			$orig_length = $orig{"tracklength$i"};
			#			$orig_artistid = $orig{getField($i, "artistid")};
			#			last;
			#		}
			#	}
			#}

			if (defined $orig_seq and $orig_seq ne $new_seq)
			{
				$m->comp(".showTrackEdit",
					mb => $mb,
					edittype => "EditTrackNumberEdit",
					edittitle => "Edit track number",

					new_seq => $new_seq,
					new_id => $new_id,
					oldvalue => $orig_seq,
					newvalue => $new_seq,
					modtype => &ModDefs::MOD_EDIT_TRACKNUM,
					cnt => ++$trackchanges
				);
			}


			# if tracknames differ, it's either an edited or added track
			if ($orig_track ne $new_track)
			{
				$m->comp(".showTrackEdit",
					mb => $mb,
					edittype => "AddTrackNameEdit",
					edittitle => "Add Track",

					new_seq => $new_seq,
					new_id => $new_id,
					oldvalue => "",
					newvalue => $new_track,
					modtype => &ModDefs::MOD_ADD_TRACK,
					cnt => ++$trackchanges
				) if ($orig_track eq "");

				$m->comp(".showTrackEdit",
					mb => $mb,
					edittype => "EditTrackNameEdit",
					edittitle => "Edit track title",

					title => "Edit name",
					new_seq => $new_seq,
					new_id => $new_id,
					oldvalue => $orig_track,
					newvalue => $new_track,
					modtype => &ModDefs::MOD_EDIT_TRACKNAME,
					cnt => ++$trackchanges
				) if ($orig_track ne "");
			}

			# if tracknames differ, it's either an edited or added track
			if (defined $orig_artistid and $orig_artistid ne $new_artistid
				and not $movetracks)
			{
				my $orig_artist = &$GetCachedArtist($orig_artistid),
				my $new_artist = &$GetCachedArtist($new_artistid);
				$m->comp(".showTrackEdit",
					mb => $mb,
					edittype => "ChangeTrackArtistEdit",
					edittitle => "Change track artist",

					new_seq => $new_seq,
					new_id => $new_id,

					oldvalue => $orig_artist,
					newvalue => $new_artist,
					new_artistname => $ARGS{getField($t, "artistname")},
					new_resolution => $ARGS{getField($t, "artistresolution")},
					modtype => &ModDefs::MOD_CHANGE_TRACK_ARTIST,
					cnt => ++$trackchanges
				);
			}

			# check if edited track time
			if ($orig_length != $new_length)
			{
				$m->comp(".showTrackEdit",
					mb => $mb,
					edittype => "EditTrackTimeEdit",
					edittitle => "Edit track time",

					new_seq => $new_seq,
					new_id => $new_id,
					oldvalue => MusicBrainz::Server::Track::FormatTrackLength($orig_length),
					newvalue => MusicBrainz::Server::Track::FormatTrackLength($new_length),
					modtype => &ModDefs::MOD_EDIT_TRACKTIME,
					cnt => ++$trackchanges
				);
			}
		}

		if (not $trackchanges)
		{

</%perl>
				<tr class="nochanges"><td colspan="3">You have not made any track changes</td></tr>

%		}

				<tr class="spacer"><td colspan="3">&nbsp;</td></tr>
			</table>

%	}


	<& /comp/tableend &>

	<& /comp/tablebegin, title => $editmode ? "Enter edits" : "Review release" &>

		<div style="margin-left: 40px">

			<table width="600">
				<tr>
					<td>
						<& "/comp/artisttitle",
							artist => $artist,
							link => 0,
							showmodlinks => 0, &>

						<& "/comp/album",
							album => $release,
							artist => $artist,
							showlinks => 0,
							showmodlinks => 0,
							showreleases => 1,
							tracks => \@tracks,
							releaseevents => \@revnew, &>
					</td>
				</tr>
				<tr>
					<td style="text-align: left">
						<script type="text/javascript" src="/scripts/editsuite.js"></script>

						<& /comp/js/diffcollapse, JSDiff => 1, JSCollapse => 0 &>

						<form  method="post" action="<% $ARGS{"v::action"} %>">
%	my $notetext = $ARGS{"notetext"};
%	delete $ARGS{"notetext"};
							<& /comp/args-to-hidden-fields.inc,
								$m->comp("/comp/form/args-strip-editsuitefields", %ARGS) &>

%	my @buttons;
%	push @buttons, [$ARGS{"SUBMIT_ENTEREDITS"}, "btnYes", !$releasechanges && !$trackchanges] if ($editmode);
%	push @buttons, [$ARGS{"SUBMIT_ADDRELEASE"}, "btnYes"] if (!$editmode);
%	push @buttons, [$ARGS{"SUBMIT_KEEPEDITING"}, ""];
%	push @buttons, [$ARGS{"SUBMIT_STARTOVER"}, ""] if ($releaseid);
%	push @buttons, [$ARGS{"SUBMIT_CANCEL"}, "btnCancel"];

							<& /comp/notetext,
								notetext => $notetext,
								buttons => \@buttons &>

							<& /comp/form/focusfield, "btnYes" &>

						</form>
					</td>
				</tr>
			</table>

		</div>

	<& /comp/tableend &>


%#	isAutoEdit
%#	---------------------------------------------------------------------------
%#	Outputs the raw HTML code if the given
%#	Edit-Type is an Automoderation for the current user.
<%def .isAutoEdit>
<%perl>
	return;

	my ($type) = @_;

	# my $user_is_automod = UserStuff->IsAutoEditor($session{privs};

    # my $automod = $this->IsAutoEdit($user_is_automod);
	# $automod = 0 if $ui->IsUntrusted($privs)
	#	and ($type != &ModDefs::MOD_ADD_PUIDS);
	# $automod = 1
	# 	if not $automod
	# 	and $user_is_automod
	# 	and $this->IsAutoEditType($type);

	# $m->out("1: ".Moderation->IsAutoEditType($type));
	# $m->out("2: ".UserStuff->IsAutoEditor($session{privs}));

	if (Moderation->IsAutoEditType($type) ||
		UserStuff->IsAutoEditor($session{privs}))
	{
		$m->out('No <span style="font-size: 10px">(<a href="/mod_intro.html#automod">autoedit</a>)</span>')
	}
	else
	{
		$m->out('Yes');
	}

</%perl>
</%def>


%#	doDiffTable
%#	---------------------------------------------------------------------------
%#	Outputs the raw HTML for a diff table
<%def .doDiffTable>
% 	my ($diffref, $ov, $nv) = @_;

	<table class="editdiff">
		<tr>
			<td class="diff" id="ov::<% $diffref %>"><% $ov %></td>
		</tr>
		<tr>
			<td class="diff" id="nv::<% $diffref %>"><% $nv %></td>
		</tr>
	</table>

</%perl>
</%def>

%#	showArtistEdit
%#	---------------------------------------------------------------------------
%#	Outputs the raw HTML for artist edit
<%def .showArtistEdit>
<%args>

	$mb
	$title
	$orig_artist
	$new_artist
	$new_artistname => ""
	$new_resolution => ""

</%args>
<%perl>

	$m->out(sprintf '<tr><td class="type">%s</td><td class="newvalue">', $title);
	$m->comp("/comp/linkartist", artist => $orig_artist);
	$m->out('<br/>');
	$m->comp("/comp/linkartist", artist => $new_artist);
	$m->out('</td>');
	$m->out('<td class="autoedit">');
	$m->comp(".isAutoEdit", &ModDefs::MOD_MOVE_RELEASE);
	$m->out('</td></tr>');

</%perl>
</%def>


%#	showReleaseEdit
%#	---------------------------------------------------------------------------
%#	Outputs the raw HTML for release edit
<%def .showReleaseEdit>
<%args>

	$mb
	$edittype
	$edittitle

	$oldvalue
	$newvalue
	$modtype
	$cnt

</%args>
<%perl>

	$m->out('<tr>');
	$m->out('<td class="type">');
	$m->comp("/comp/linkdoc", $edittype, $edittitle) if ($edittype);
	$m->out('</td>');
	$m->out('<td class="newvalue">');
	$m->comp(".doDiffTable", "release$cnt", $oldvalue, $newvalue)
		if ($oldvalue ne "" and $newvalue ne "");
	$m->out($oldvalue)
		if ($oldvalue ne "" and $newvalue eq "");
	$m->out($newvalue)
		if ($newvalue ne "" and $oldvalue eq "");
	$m->out('</td>');
	$m->out('<td class="autoedit">');
	$m->comp(".isAutoEdit", $modtype);
	$m->out('</td>');
	$m->out('</tr>');

</%perl>
</%def>

%#	showTrackEdit
%#	---------------------------------------------------------------------------
%#	Outputs the raw HTML for track edit
<%def .showTrackEdit>
<%args>

	$mb
	$edittype
	$edittitle

	$new_seq
	$new_id
	$oldvalue
	$newvalue

	# used for MOD_CHANGE_TRACK_ARTIST, if the
	# artist is a a *new* artist
	$new_artistname => ""
	$new_resolution => ""

	$modtype
	$cnt

</%args>
<%perl>

	$m->out('<tr>');
	$m->out('<td class="type">');
	$m->out('<b>'.$new_seq.':</b> ');
	$m->comp("/comp/linkdoc", $edittype, $edittitle);
	$m->out('</td>');
	$m->out('<td class="newvalue">');

	if ($modtype == &ModDefs::MOD_CHANGE_TRACK_ARTIST)
	{
		$m->comp("/comp/linkartist", artist => $oldvalue);
		$m->out('<br/>');
		$m->comp("/comp/linkartist", artist => $newvalue);
	}
	else
	{
		# render diff table, or singe value if they are set.
		$m->comp(".doDiffTable", "track$cnt", $oldvalue, $newvalue)
			if ($oldvalue ne "" and $newvalue ne "");
		$m->out($oldvalue)
			if ($oldvalue ne "" and $newvalue eq "");
		$m->out($newvalue)
			if ($newvalue ne "" and $oldvalue eq "");
	}
	$m->out('</td>');
	$m->out('<td class="autoedit">');
	$m->comp(".isAutoEdit", $modtype);
	$m->out('</td>');
	$m->out('</tr>');

</%perl>
</%def>

%# vi: set ts=4 sw=4 ft=mason :
